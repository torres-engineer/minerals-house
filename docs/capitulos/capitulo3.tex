\chapter{Implementação}

\section{Arquitetura geral}
\section{Modelo de dados}
\section{O mapa e o motor gráfico}
\section{Sistema de navegação e pathfinding}
\section{Interface com o utilizador}
\section{Sistema de questionários}




%isto ta aqui enquanto depois meter no lado certo 
Começamos por pensar de que forma íamos implementar o jogo. Como o
nosso objetivo e eventualmente o jogo ser multiplataforma, surgiu a
ideia de usarmos a biblioteca \href{https://www.raylib.com/}{Raylib}.
E uma biblioteca bem simples, mas que faz tudo o que necessitamos. E
fácil de usar e tem uma boa documentação e exemplos. Agora só tivemos
de pensar como e que faríamos para usar o Raylib para a Web. A
resposta talvez seja obvia, precisávamos de usar WebAssembly (WASM).
Mas ainda tivemos de decidir entre compilar a biblioteca Raylib para
WASM, ou ter a logica do jogo em WASM mas depois usar as API que os
navegadores Web oferecem para criar a parte gráfica do jogo.
Escolhemos a segunda. Parece ser a que causa menos problemas, apesar
de que agora temos de manter duas interfaces gráficas diferentes: A
que usa a API Canvas do HTML, e a que usa Raylib.

Bom, e agora, em que linguagem vamos criar a logica e a interface
gráfica do jogo? Tínhamos basicamente qualquer linguagem com FFI,
quase todas as linguagens compiladas e que conseguem dar link com
binarios compilados criando ABI shims. Raylib e implementada em C,
mas a comunidade já criou bindings para múltiplas linguagens. Nós
queríamos usar uma linguagem que ainda não tínhamos usado, como forma
de aprender essa linguagem e os seus paradigmas, mas também para
mostrar que somos programadores, independentemente da linguagem. Um
de nos lembrou-se da linguagem \href{https://odin-lang.org/}{Odin} e
não discutimos mais acerca disso. Por acaso a linguagem já tem até um
binding oficial para o Raylib, nesse sentido facilitou o nosso
trabalho. Odin oferece programação de vetores, matrizes e quaterniões
como tipo de dados, e estruturas de dados que facilitam programação
SIMD e SIMT, que talvez não iremos usar diretamente, mas que com
certeza ajuda bastante na criação de jogos 3D, na performance.

Também tivemos a surpresa da linguagem estar relativamente preparada
para compilação em WebAssembly, sem ter de fazer trabalho
intermediário com
\href{https://emscripten.org/index.html}{Emscripten}, LLVM e
ficheiros de objetos, e ainda a gestão da memoria no JavaScript, já
que Odin oferece um ficheiro preparado para o runtime, com integração
com DOM e até WebGL.

Odin não é uma linguagem qualquer, e já tem usos no mundo
profissional, por exemplo, \href{https://jangafx.com/}{JangaFX}
desenvolve ferramentas como EmberGen, GeoGen e LiquiGen inteiramente
em Odin, mostrando o desempenho e a facilidade da linguagem para
aplicações gráficas complexas. E é isso. Depois conforme a
necessidade podemos ir buscar outras bibliotecas, mas por enquanto, basta.